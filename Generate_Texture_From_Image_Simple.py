# This code uses OpenRouter API to generate a code that creates number of texture images based on reference texture image. The code generated by the LLM is expected to capture the underlying process that generates the texture and not just mimic the appearance of the input texture.
import cv2
import base64, requests
from pathlib import Path
import json
import os
API_key = ""
InDir="sample_images//"
OutDir="out_img_dir//"



model="google/gemini-3-flash-preview"

##############################################################################################
def replicate_concept_simple(API_key,input_image_path,output_dir,model,num_im=10): # the num_im parameter specifies how many different images the generated code should create based on the underlying system of the input texture image
    if not os.path.exists(output_dir): os.mkdir(output_dir)
    output_img_dir=output_dir+"/generated_images/"
    if not os.path.exists(output_img_dir): os.mkdir(output_img_dir)

    prompt = ("Look at the image and write python code that recreates the system in the image."
              "Identify the underlying system, pattern, or process that generates the content of the image and write code to simulate this system. Try model the actual  system and not just mimic the image appearance. "
              "The code should contain a function generate(out_dir,num_im) that generated num_im images and save them into out_path (the num_im output images need to be different from each other)."
              "Do not display the image or use any GUI functions. Dont use matplotlib.pyplot."
              "Your response must come as a parsable json of the following format: {'code':<only code ready to execute>,'describe':<describe what you see in the image>}."
              "Respond with raw JSON only. Do not use Markdown.Do not wrap the response in code fences. Output must be directly parsable by JSON.parse.")
    image_data_url = "data:image/jpeg;base64," + base64.b64encode(Path(input_image_path).read_bytes()).decode() # encode input image as data URL
    content = [
                {"type": "text", "text": prompt},

                {"type": "image_url", "image_url": {"url": image_data_url}},
            ]
    r = requests.post( # send request to OpenRouter API
        "https://openrouter.ai/api/v1/chat/completions",
        headers={"Authorization": f"Bearer {API_key}"},
        json={
            "model": model,
            "messages": [{
                "role": "user",
                "content": content,
            }],
        },
    )
    txt=r.json()['choices'][0]["message"]['content'] # get the content of the response

    dic = json.loads(txt)  # parse the response as json
    code = dic['code']  # get the code
    if "matplotlib.pyplot." in code: return 0
    namespace1 = {}
    print("\n\n\n\n",code)
    exec(code,namespace1) # execute the generated code to define the generate function

    namespace1["generate"](output_img_dir,num_im) # call the generate function to create num_im images in the output_img_dir based on the underlying system of the input texture image
    if os.path.exists(output_img_dir) and len(os.listdir(output_img_dir))>=num_im-1: # check if the expected number of images are generated (allowing for one failure)
            with open(output_dir + "//code.py", "w") as f: f.write(code)
            cv2.imwrite(output_dir + "//input_image.jpg",cv2.imread(input_image_path))
            with open(output_dir + "//finish.txt", "w") as f: f.write("Finished successfully")
            if 'describe' in dic:
                with open(output_dir + "//description.txt", "w") as f: f.write(dic['describe'])


##################################################################33333
if __name__ == "__main__":
    if not os.path.exists(OutDir): os.mkdir(OutDir)
    for fl in os.listdir(InDir):
        output_dir = os.path.join(OutDir,fl.replace(".jpg","").replace(".png","").replace(".",""))
        if os.path.exists(output_dir+"//finish.txt"): continue
        try:
           replicate_concept_simple(API_key,InDir+"//"+fl,output_dir,model)
        except Exception as error:
            debug_error=str(error)
            print("Error in processing file:",fl,"Error:",debug_error)
